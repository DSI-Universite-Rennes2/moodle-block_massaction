{"version":3,"file":"checkboxmanager.min.js","sources":["../src/checkboxmanager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Checkbox manager amd module: Adds checkboxes to the activities for selecting and\n * generates a data structure of the activities and checkboxes.\n *\n * @module     block_massaction/checkboxmanager\n * @copyright  2022 ISB Bayern\n * @author     Philipp Memmel\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {exception as displayException} from 'core/notification';\nimport {cssIds, constants, usedMoodleCssClasses} from './massactionblock';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport events from 'core_course/events';\n\nlet localStateUpdating = false;\nlet sectionsChanged = false;\nlet sections = [];\nlet moduleNames = [];\n\n/* A registry of checkbox IDs, of the format:\n *  'section_number' => [{'moduleId'   : <module-ID>,\n *                       'boxId'       : <checkbox_id>}]\n */\nconst sectionBoxes = {};\n\n/**\n * The checkbox manager takes a given 'sections' data structure object and inserts a checkbox for each of the given\n * course modules in this data object into the DOM.\n * The checkbox manager returns another data object containing the ids of the added checkboxes.\n */\nexport const initCheckboxManager = () => {\n    const courseEditor = getCurrentCourseEditor();\n\n    const eventsToListen = {\n        SECTION_UPDATED: 'section:updated',\n        CHANGE_FINISHED: 'transaction:end'\n    };\n\n    courseEditor.stateManager.target.addEventListener(events.stateChanged, (event) => {\n        if (event.detail.action === eventsToListen.SECTION_UPDATED) {\n            // Listen to section updated events. We do not want to immediately react to the event, but wait for\n            // everything to finish updating.\n            sectionsChanged = true;\n        }\n        if (event.detail.action === eventsToListen.CHANGE_FINISHED) {\n            // Before every change to the state there is a transaction:start event. After the change is being commited,\n            // we receive an transaction:end event. That is the point we want to react to changes of the state.\n            rebuildLocalState();\n        }\n    });\n    // Trigger rendering of sections dropdowns a first time.\n    sectionsChanged = true;\n    // Get initial state.\n    rebuildLocalState();\n};\n\n/**\n * This method rebuilds the local state maintained in this module based on the course editor state.\n *\n * It will be called whenever a change to the courseeditor state is being detected.\n */\nconst rebuildLocalState = () => {\n    if (localStateUpdating) {\n        return;\n    }\n    localStateUpdating = true;\n    const courseEditor = getCurrentCourseEditor();\n\n    // First we rebuild our data structures depending on the course editor state.\n    sections = [];\n    for (const prop of Object.getOwnPropertyNames(sectionBoxes)) {\n        delete sectionBoxes[prop];\n    }\n    // The section map object is being sorted by section id. We have to sort after order in this course.\n    sections = [...courseEditor.stateManager.state.section.values()].sort((a, b) => a.number > b.number ? 1 : -1);\n    moduleNames = [...courseEditor.stateManager.state.cm.values()];\n\n    // Now we use the new information to rebuild dropdowns and re-apply checkboxes.\n    const sectionsUnfiltered = sections;\n    sections = filterVisibleSections(sections);\n    updateSelectionAndMoveToDropdowns(sections, sectionsUnfiltered);\n    addCheckboxes();\n    localStateUpdating = false;\n};\n\n/**\n * Returns the currently selected module ids.\n *\n * @returns {[]} Array of module ids currently being selected\n */\nexport const getSelectedModIds = () => {\n    const moduleIds = [];\n    for (let sectionNumber in sectionBoxes) {\n        for (let i = 0; i < sectionBoxes[sectionNumber].length; i++) {\n            const checkbox = document.getElementById(sectionBoxes[sectionNumber][i].boxId);\n            if (checkbox.checked) {\n                moduleIds.push(sectionBoxes[sectionNumber][i].moduleId);\n            }\n        }\n    }\n    return moduleIds;\n};\n\n/**\n * Select all module checkboxes in section(s).\n *\n * @param {boolean} value the checked value to set the checkboxes to\n * @param {string} sectionNumber the section number of the section which all modules should be checked/unchecked. Use \"all\" to\n *  select/deselect modules in all sections.\n */\nexport const setSectionSelection = (value, sectionNumber) => {\n    const boxIds = [];\n\n    if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_SELECT_DESCRIPTION_VALUE) {\n        // Description placeholder has been selected, do nothing.\n        return;\n    } else if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_NUMBER_ALL_PLACEHOLDER) {\n        // See if we are toggling all sections.\n        for (const sectionId in sectionBoxes) {\n            for (let j = 0; j < sectionBoxes[sectionId].length; j++) {\n                boxIds.push(sectionBoxes[sectionId][j].boxId);\n            }\n        }\n    } else {\n        // We select all boxes of the given section.\n        sectionBoxes[sectionNumber].forEach(box => boxIds.push(box.boxId));\n    }\n    // Un/check the boxes.\n    for (let i = 0; i < boxIds.length; i++) {\n        document.getElementById(boxIds[i]).checked = value;\n    }\n};\n\n/**\n * Add checkboxes to all sections.\n */\nconst addCheckboxes = () => {\n    sections.forEach(section => {\n        sectionBoxes[section.number] = [];\n        const moduleIds = section.cmlist;\n        if (moduleIds && moduleIds.length > 0 && moduleIds[0] !== '') {\n            const moduleNamesFiltered = moduleNames.filter(modinfo => moduleIds.includes(modinfo.id.toString()));\n            moduleNamesFiltered.forEach(modinfo => {\n                addCheckboxToModule(section.number, modinfo.id.toString(), modinfo.name);\n            });\n        }\n    });\n};\n\n/**\n * Add a checkbox to a module element\n *\n * @param {number} sectionNumber number of the section of the current course module\n * @param {number} moduleId id of the current course module\n * @param {string} moduleName name of the course module specified by moduleId\n */\nconst addCheckboxToModule = (sectionNumber, moduleId, moduleName) => {\n    const boxId = cssIds.BOX_ID_PREFIX + moduleId;\n    const moduleElement = document.getElementById(usedMoodleCssClasses.MODULE_ID_PREFIX + moduleId)\n        .querySelector(usedMoodleCssClasses.ACTIVITY_ITEM);\n\n    // Avoid creating duplicate checkboxes.\n    if (document.getElementById(boxId) === null) {\n        // Add the checkbox.\n        const checkBoxElement = document.createElement('input');\n        checkBoxElement.type = 'checkbox';\n        checkBoxElement.className = cssIds.CHECKBOX_CLASS;\n        checkBoxElement.id = boxId;\n\n        if (moduleElement !== null) {\n            const checkboxDescription = moduleName + constants.CHECKBOX_DESCRIPTION_SUFFIX;\n            checkBoxElement.ariaLabel = checkboxDescription;\n            checkBoxElement.name = checkboxDescription;\n            // Finally add the created checkbox element.\n            moduleElement.insertBefore(checkBoxElement, moduleElement.firstChild);\n        }\n    }\n\n    // Add the newly created checkbox to our data structure.\n    sectionBoxes[sectionNumber].push({\n        'moduleId': moduleId,\n        'boxId': boxId,\n    });\n};\n\n/**\n * Filter the sections data object depending on the visibility of the course modules contained in\n * the data object. This is neccessary, because some course formats only show specific section(s)\n * in editing mode.\n *\n * @param {[]} sections the sections data object\n * @returns {[]} the filtered sections object\n */\nconst filterVisibleSections = (sections) => {\n    // Filter all sections with modules which no checkboxes have been created for.\n    // This case should only occur in course formats where some sections are hidden.\n    return sections.filter(section => section.cmlist.length !== 0)\n        .filter(section => section.cmlist\n            .every(moduleid => document.getElementById(usedMoodleCssClasses.MODULE_ID_PREFIX + moduleid) !== null));\n};\n\n/**\n * Update the selection, moveto and duplicateto dropdowns of the massaction block according to the\n * previously filtered sections.\n *\n * This method also has to be called whenever there is a module change event (moving around, adding file by Drag&Drop etc.).\n *\n * @param {[]} sections the sections object filtered before by {@link filterVisibleSections}\n * @param {[]} sectionsUnfiltered the same data object as 'sections', but still containing all sections\n * no matter if containing modules or are visible in the current course format or not\n */\nconst updateSelectionAndMoveToDropdowns = (sections, sectionsUnfiltered) => {\n    if (sectionsChanged) {\n        Templates.renderForPromise('block_massaction/section_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.SECTION_SELECT, html, js);\n                disableInvisibleAndEmptySections(sections);\n                // Re-register event listener.\n                document.getElementById(cssIds.SECTION_SELECT).addEventListener('click',\n                    (event) => setSectionSelection(true, event.target.value), false);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/moveto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.MOVETO_SELECT, html, js);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/duplicateto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.DUPLICATETO_SELECT, html, js);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n    } else {\n        // If there has not been an event about a section change we do not have to rebuild the sections dropdowns.\n        // However there is a chance an section is being emptied or not empty anymore due to drag&dropping of modules.\n        // So we have to recalculate if we have to enable/disable the sections.\n        disableInvisibleAndEmptySections(sections);\n    }\n    // Reset the flag.\n    sectionsChanged = false;\n};\n\n/**\n * Sets the disabled/enabled status of sections in the section select dropdown:\n * Enabled if section is visible and contains modules.\n * Disabled if section is not visible or doesn't contain any modules.\n *\n * @param {[]} sections the section data structure\n */\nconst disableInvisibleAndEmptySections = (sections) => {\n    Array.prototype.forEach.call(document.getElementById(cssIds.SECTION_SELECT).options, option => {\n        // Disable every element which doesn't have a visible section, except the placeholder ('description').\n        if (option.value !== constants.SECTION_SELECT_DESCRIPTION_VALUE\n                && !sections.some(section => parseInt(option.value) === section.number)) {\n            option.disabled = true;\n        } else {\n            option.disabled = false;\n        }\n    });\n};\n"],"names":["localStateUpdating","sectionsChanged","sections","moduleNames","sectionBoxes","courseEditor","eventsToListen","stateManager","target","addEventListener","events","stateChanged","event","detail","action","rebuildLocalState","prop","Object","getOwnPropertyNames","state","section","values","sort","a","b","number","cm","sectionsUnfiltered","filterVisibleSections","updateSelectionAndMoveToDropdowns","addCheckboxes","moduleIds","sectionNumber","i","length","document","getElementById","boxId","checked","push","moduleId","setSectionSelection","value","boxIds","constants","SECTION_SELECT_DESCRIPTION_VALUE","SECTION_NUMBER_ALL_PLACEHOLDER","sectionId","j","forEach","box","cmlist","filter","modinfo","includes","id","toString","addCheckboxToModule","name","moduleName","cssIds","BOX_ID_PREFIX","moduleElement","usedMoodleCssClasses","MODULE_ID_PREFIX","querySelector","ACTIVITY_ITEM","checkBoxElement","createElement","type","className","CHECKBOX_CLASS","checkboxDescription","CHECKBOX_DESCRIPTION_SUFFIX","ariaLabel","insertBefore","firstChild","every","moduleid","renderForPromise","then","_ref","html","js","replaceNode","SECTION_SELECT","disableInvisibleAndEmptySections","catch","ex","_ref2","MOVETO_SELECT","_ref3","DUPLICATETO_SELECT","Array","prototype","call","options","option","some","parseInt","disabled"],"mappings":"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"}